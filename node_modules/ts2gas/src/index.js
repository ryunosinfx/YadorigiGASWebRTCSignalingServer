"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const typescript_1 = __importDefault(require("typescript"));
// type guards helpers
const { isArray } = Array;
const isObject = (v) => typeof v === 'object';
/**
 * Transpiles a TypeScript file into a valid Apps Script file.
 * @param {string} source The TypeScript source code as a string.
 * @param {ts.TranspileOptions} transpileOptions custom transpile options.
 * @see https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API
 */
const ts2gas = (source, transpileOptions = {}) => {
    /**
     *  Create a commented-out statement
     * @param {ts.Node} node The node to coment-out.
     */
    function createCommentedStatement(node) {
        const ignoredNode = typescript_1.default.createNotEmittedStatement(node);
        typescript_1.default.addSyntheticTrailingComment(ignoredNode, typescript_1.default.SyntaxKind.SingleLineCommentTrivia, node.getText().replace(/\n/g, '\\n'));
        return ignoredNode;
    }
    /**
     * Create a 'before' Transformer callback function
     * It use 'createCommentedStatement' to comment-out filtered node
     * @param {NodeFilter} nodeFilter The node visitor used to transform.
     */
    const ignoreNodeBeforeBuilder = (nodeFilter) => (context) => {
        return (sf) => visitNode(sf);
        function visitNode(node) {
            if (nodeFilter(node)) {
                return createCommentedStatement(node);
            }
            return typescript_1.default.visitEachChild(node, visitNode, context); // resume processing
        }
    };
    /**
     * Create a 'before' Transformer callback function
     * It use applies the 'NoSubstitution' flag on every node
     * @param {NodeFilter} nodeFilter The node visitor used to transform (unused here).
     */
    const noSubstitutionBeforeBuilder = (nodeFilter) => (context) => {
        return (sf) => visitNode(sf);
        function visitNode(node) {
            if (nodeFilter(node) // node kind is Identifier
                // do not process if parent kind is EnumDeclaration
                && !(node.parent && typescript_1.default.isEnumDeclaration(node.parent))) {
                typescript_1.default.setEmitFlags(node, typescript_1.default.EmitFlags.NoSubstitution);
            }
            return typescript_1.default.visitEachChild(node, visitNode, context); // resume processing
        }
    };
    /**
     * Create an 'after' Transformer callback function to ignore filered nodes
     * @param {ts.SyntaxKind} kind the kind of node to filter.
     * @param {NodeFilter} nodeFilter The node visitor used to transform.
     */
    const ignoreNodeAfterBuilder = (kind, nodeFilter) => (context) => {
        const previousOnSubstituteNode = context.onSubstituteNode;
        context.enableSubstitution(kind);
        context.onSubstituteNode = (hint, node) => {
            node = previousOnSubstituteNode(hint, node);
            if (nodeFilter(node)) {
                /** Do not emit this node */
                node = typescript_1.default.createNotEmittedStatement(node);
            }
            return node;
        };
        return (file) => file;
    };
    // Before transpiling, apply these touch-ups:
    const identifierFilter = (node) => {
        return typescript_1.default.isIdentifier(node);
    };
    const noSubstitution = noSubstitutionBeforeBuilder(identifierFilter);
    // ## Imports
    // Some editors (like IntelliJ) automatically import identifiers.
    // Individual imports lines are commented out
    // i.e. import GmailMessage = GoogleAppsScript.Gmail.GmailMessage;
    /** filter all import declaration nodes */
    const importNodeFilter = (node) => typescript_1.default.isImportEqualsDeclaration(node) || typescript_1.default.isImportDeclaration(node);
    const ignoreImport = ignoreNodeBeforeBuilder(importNodeFilter);
    // source = source.replace(/^.*import /mg, '// import ');
    // ## Exports
    // replace exports like `export * from 'file'`
    /** filter export...from declaration nodes */
    const exportFromNodeFilter = (node) => typescript_1.default.isExportDeclaration(node) // 'export ...'
        && !!node.getChildren().find(e => e.kind === typescript_1.default.SyntaxKind.FromKeyword); // 'from'
    const ignoreExportFrom = ignoreNodeBeforeBuilder(exportFromNodeFilter);
    // source = source.replace(/(^\s*export.*from\s*['"][^'"]*['"])/mg, '// $1');
    // After transpiling, apply these touch-ups:
    // ## exports.__esModule
    // Remove all lines that have exports.__esModule = true
    // @see https://github.com/Microsoft/TypeScript/issues/14351
    /** filter all added expression statement nodes */
    const exportEsModuleNodeFilter = (node) => typescript_1.default.isExpressionStatement(node)
        && node.pos === -1 && node.end === -1 // hint it was added by tranpiler
        && typescript_1.default.isBinaryExpression(node.expression)
        && typescript_1.default.isPropertyAccessExpression(node.expression.left)
        && typescript_1.default.isIdentifier(node.expression.left.expression)
        && typescript_1.default.idText(node.expression.left.expression) === 'exports'
        && typescript_1.default.idText(node.expression.left.name) === '__esModule';
    const removeExportEsModule = ignoreNodeAfterBuilder(typescript_1.default.SyntaxKind.ExpressionStatement, exportEsModuleNodeFilter);
    // output = output.replace('exports.__esModule = true;', ''); // Remove this line
    // Remove default exports
    // (Transpiled `exports["default"]`)
    /**  Filter ts.Node which are statement assigning to 'exports["default"]' */
    const exportsDefaultNodeFilter = (node) => typescript_1.default.isExpressionStatement(node)
        && typescript_1.default.isBinaryExpression(node.expression) // is it a binary expression
        && typescript_1.default.isPropertyAccessExpression(node.expression.left)
        && typescript_1.default.isIdentifier(node.expression.left.expression) // is it 'exports'
        && typescript_1.default.idText(node.expression.left.expression) === 'exports'
        && typescript_1.default.isIdentifier(node.expression.left.name) // is it 'default'
        && typescript_1.default.idText(node.expression.left.name) === 'default'
        && node.expression.operatorToken.kind === typescript_1.default.SyntaxKind.EqualsToken // '='
        && typescript_1.default.isIdentifier(node.expression.right);
    /** A ts.TransformerFactory which removes 'exports["default"]' statements */
    const removeExportsDefault = ignoreNodeAfterBuilder(typescript_1.default.SyntaxKind.ExpressionStatement, exportsDefaultNodeFilter);
    // output = output.replace(/^\s*exports\[\"default\"\].*$\n/mg, '');
    /** These settings can be overriden */
    const defaults = {
        compilerOptions: {
            experimentalDecorators: true,
            noImplicitUseStrict: true,
            target: typescript_1.default.ScriptTarget.ES3,
        },
    };
    /**
     * These the settings are always used and cannot be overriden
     *
     * Extra compiler options that will unconditionally be used by this function are
     * - isolatedModules = true
     * - noLib = true
     * - noResolve = true
     */
    const statics = {
        compilerOptions: {
            emitDeclarationOnly: false,
            module: typescript_1.default.ModuleKind.None,
        },
        transformers: {
            before: [noSubstitution, ignoreExportFrom, ignoreImport],
            after: [removeExportEsModule, removeExportsDefault],
        },
    };
    // keep only overridable properties
    if (typeof transpileOptions === 'object') {
        const { compilerOptions, renamedDependencies } = transpileOptions;
        transpileOptions = { compilerOptions, renamedDependencies };
    }
    else {
        transpileOptions = {};
    }
    // merge properties in order for proper override
    transpileOptions = deepAssign({}, // safe to mutate
    defaults, // default (overridable)
    transpileOptions, // user override
    statics);
    // Transpile (cf. https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    const result = typescript_1.default.transpileModule(source, transpileOptions);
    // # Clean up output (multiline string)
    let output = result.outputText;
    // ## Exports
    // Exports are transpiled to variables 'exports' and 'module.exports'
    const pjson = require('../package.json'); // ugly hack
    // Include an exports object in all files.
    output = `// Compiled using ${pjson.name} ${pjson.version} (TypeScript ${typescript_1.default.version})
var exports = exports || {};
var module = module || { exports: exports };
${output}`;
    return output;
    /**
     * A 'good enough' recursive Object.assign like function
     * Properties from sources are add or overwriten on target.
     * If the value is a object, then recursion is applied
     * If the value is an array, then concatenation occurs
     * @param {KeyedMap} target The target object to mutate.
     * @param {KeyedMap[]} tar...sourcesget one or more objects to assign.
     */
    function deepAssign(target, ...sources) {
        for (const source of sources) {
            const keys = Object.keys(source);
            for (const key of keys) {
                const targetValue = target.hasOwnProperty(key)
                    ? target[key]
                    : undefined;
                if (source.hasOwnProperty(key)) {
                    const value = source[key];
                    if (isArray(value)) {
                        target[key] = isArray(targetValue) ? [...targetValue, ...value] : value;
                    }
                    else if (isObject(value)) {
                        target[key] = deepAssign(isObject(targetValue) ? targetValue : {}, value);
                    }
                    else if (typeof value !== 'undefined') {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    }
};
module.exports = ts2gas;
